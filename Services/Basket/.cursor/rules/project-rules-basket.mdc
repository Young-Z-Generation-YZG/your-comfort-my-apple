---
globs:
    - "Services/Basket/**"
    - "!**/node_modules/**"
    - "!**/.next/**"
AI:
    alwaysApply: true
---

# Basket Service Project Rules

These rules apply **only** to the Basket microservice located in `Services/Basket`.

## Architecture Pattern

-   **Clean Architecture** with Domain-Driven Design (DDD):
    -   **Domain Layer** (`YGZ.Basket.Domain`): Core business entities (ShoppingCart, ShoppingCartItem), value objects (Model, Color, Storage, Promotion, PromotionCoupon, PromotionEvent), domain events, domain errors, and domain logic. No dependencies on other layers.
    -   **Application Layer** (`YGZ.Basket.Application`): Use cases, commands, queries, handlers (CQRS), validators, and application services. Depends only on Domain.
    -   **Infrastructure Layer** (`YGZ.Basket.Infrastructure`): Data access (MongoDB), caching (Redis), payment providers (Vnpay, Momo), external services. Implements interfaces defined in Application/Domain.
    -   **API Layer** (`YGZ.Basket.Api`): Controllers, request/response DTOs, middleware, dependency injection setup. Entry point for HTTP/gRPC.

## CQRS Pattern

-   Use **MediatR** for CQRS implementation:
    -   Commands: Implement `ICommand<TResponse>` from `YGZ.BuildingBlocks.Shared.Abstractions.CQRS`
    -   Queries: Implement `IQuery<TResponse>` from `YGZ.BuildingBlocks.Shared.Abstractions.CQRS`
    -   Handlers: Implement `ICommandHandler<TCommand, TResponse>` or `IQueryHandler<TQuery, TResponse>`
-   Commands and queries must return `Result<TResponse>` from `YGZ.BuildingBlocks.Shared.Abstractions.Result`
-   Organize by feature: `Application/ShoppingCarts/Commands/{CommandName}/` and `Application/ShoppingCarts/Queries/{QueryName}/`
-   Each command/query should be in its own folder containing: `{Command/Query}Name.cs`, `{Command/Query}NameHandler.cs`, and optionally `{Command/Query}NameValidator.cs`

## Result Pattern

-   All handlers must return `Result<TResponse>`:
    -   Use `Result.Success(data)` for successful operations
    -   Use `Result.Failure(Error)` or `Result.ValidationFailure(ValidationError[])` for failures
-   Controllers use `result.Match(onSuccess: Ok, onFailure: HandleFailure)` pattern
-   Never throw exceptions from application layer; use Result pattern instead

## Naming Conventions

### Commands

-   **Pattern**: `{Action}{Entity}Command` (e.g., `StoreBasketCommand`, `StoreBasketItemCommand`, `CheckoutBasketCommand`, `DeleteBasketCommand`, `SyncBasketCommand`, `ProceedCheckoutCommand`)
-   **Handler**: `{CommandName}Handler` (e.g., `StoreBasketHandler`, `CheckoutBasketHandler`)
-   **Validator**: `{CommandName}Validator` (e.g., `StoreBasketValidator`)
-   **Location**: `Application/ShoppingCarts/Commands/{CommandName}/`
-   Examples:
    -   `Application/ShoppingCarts/Commands/StoreBasket/StoreBasketCommand.cs`
    -   `Application/ShoppingCarts/Commands/CheckoutBasket/CheckoutBasketCommand.cs`
    -   `Application/ShoppingCarts/Commands/StoreBasketItem/StoreBasketItemCommand.cs`

### Queries

-   **Pattern**: `Get{Entity}Query` or `Get{Entity}{Detail}Query` (e.g., `GetBasketQuery`, `GetCheckoutBasketQuery`)
-   **Handler**: `{QueryName}Handler` (e.g., `GetBasketHandler`, `GetCheckoutBasketHandler`)
-   **Location**: `Application/ShoppingCarts/Queries/{QueryName}/`
-   Examples:
    -   `Application/ShoppingCarts/Queries/GetBasket/GetBasketQuery.cs`
    -   `Application/ShoppingCarts/Queries/GetCheckoutBasket/GetCheckoutBasketQuery.cs`

### Controllers

-   **Pattern**: `{Entity}Controller` (e.g., `BasketController`)
-   **Location**: `Api/Controllers/`
-   **Route Pattern**: `[Route("api/v{version:apiVersion}/baskets")]`
-   Must inherit from `ApiController` base class
-   Use `[OpenApiTag("baskets", Description = "...")]` for Swagger documentation
-   Use `[Authorize(Policy = Policies.REQUIRE_AUTHENTICATION)]` for authentication
-   Use `[ProtectedResource(Resources.RESOURCE_USERS, Scopes.{ACTION}_OWN)]` for authorization

### Request DTOs

-   **Pattern**: `{Action}{Entity}Request` (e.g., `StoreBasketRequest`, `CheckoutBasketRequest`, `StoreBasketItemRequest`, `ProceedCheckoutRequest`)
-   **Location**: `Api/Contracts/` (e.g., `Api/Contracts/StoreBasketRequest.cs`, `Api/Contracts/CheckoutBasketRequest.cs`)
-   Use `required` keyword for required properties (C# 11+)
-   Use `[JsonPropertyName("snake_case")]` for JSON serialization naming if needed
-   Include example classes for Swagger (e.g., `StoreBasketRequestExample.cs`)

### Response DTOs

-   **Pattern**: Prefer shared contracts from `YGZ.BuildingBlocks.Shared.Contracts.Baskets` (e.g., `GetBasketResponse`, `GetCheckoutBasketResponse`)
-   For service-specific responses: `Api/Contracts/{Feature}Response/` if needed
-   Domain entities should have `ToResponse()` methods to convert to response DTOs

### Domain Entities

-   **Pattern**: `{Entity}` (e.g., `ShoppingCart`, `ShoppingCartItem`)
-   **Location**: `Domain/ShoppingCart/` (e.g., `Domain/ShoppingCart/ShoppingCart.cs`, `Domain/ShoppingCart/Entities/ShoppingCartItem.cs`)
-   Use value objects for domain concepts (e.g., `Model`, `Color`, `Storage`, `Promotion`, `PromotionCoupon`, `PromotionEvent`)
-   Use factory methods (e.g., `ShoppingCart.Create()`) for entity creation

### Value Objects

-   **Pattern**: `{Concept}` (e.g., `Model`, `Color`, `Storage`, `Promotion`, `PromotionCoupon`, `PromotionEvent`)
-   **Location**: `Domain/ShoppingCart/ValueObjects/`
-   Use `sealed record` for immutable value objects

### Domain Errors

-   **Pattern**: `Errors.{Feature}` (e.g., `Errors.Basket`, `Errors.Discount`, `Errors.Payment`)
-   **Location**: `Domain/Core/Errors/`
-   Use static methods to create error instances

### Enums

-   **Pattern**: `E{Name}` prefix (e.g., `EDiscountType`, `EPaymentMethod`, `EPromotionEvent`)
-   **Location**: `Domain/Core/Enums/`

### Cache Entities

-   **Pattern**: `{Entity}Cache` (e.g., `ColorImageCache`, `ModelSlugCache`, `PriceCache`)
-   **Location**: `Domain/Cache/Entities/`

## Feature Organization

-   **ShoppingCarts**: Shopping cart management features (store, sync, checkout, delete, etc.)
    -   Commands: `Application/ShoppingCarts/Commands/`
    -   Queries: `Application/ShoppingCarts/Queries/`
    -   Contracts: `Api/Contracts/`
    -   Domain: `Domain/ShoppingCart/`

## Payment Providers

-   **Vnpay**: Payment integration via Vnpay provider
    -   Implementation: `Infrastructure/Payments/Vnpay/VnpayProvider.cs`
    -   Settings: `Infrastructure/Settings/VnpaySettings.cs`
    -   Abstraction: `Application/Abstractions/Providers/vnpay/`
-   **Momo**: Payment integration via Momo provider
    -   Implementation: `Infrastructure/Payments/Momo/MomoProvider.cs`
    -   Settings: `Infrastructure/Settings/MomoSettings.cs`
    -   Abstraction: `Application/Abstractions/Providers/Momo/`
-   **Blockchain**: Blockchain payment support via `CheckoutBasketWithBlockchainCommand`

## Caching

-   Use **Redis** for distributed caching
-   Cache entities: `ColorImageCache`, `ModelSlugCache`, `PriceCache`
-   Cache repositories: `Infrastructure/Persistence/Repositories/{Entity}CacheRepository.cs`
-   Cache abstractions: `Application/Abstractions/Data/I{Entity}Cache.cs`
-   Use cache key prefixes from `CacheKeyPrefixConstants` in BuildingBlocks
-   Clear cache on data mutations

## Validation

-   Use **FluentValidation** for request validation
-   Validator naming: `{CommandName}Validator`
-   Location: Same folder as command (e.g., `Application/ShoppingCarts/Commands/StoreBasket/StoreBasketValidator.cs`)
-   Register validators in Application layer DI setup
-   Use `ValidationPipelineBehavior` from BuildingBlocks for automatic validation
-   Validation errors are returned via `Result.ValidationFailure(ValidationError[])`

## Multi-Tenancy

-   Use `X-TenantId` header for tenant isolation
-   Implement `ITenantHttpContext` from BuildingBlocks to access tenant context
-   Use `TenantId` value object for type-safe tenant identification
-   Apply tenant filtering in queries automatically via infrastructure layer

## Database

-   Use **MongoDB** for data persistence
-   Implement repository pattern in Infrastructure layer
-   Repository location: `Infrastructure/Persistence/Repositories/`
-   Use `IBasketRepository` abstraction in Application layer
-   Use cached repositories (e.g., `CachedBasketRepository`) for performance
-   Use `IAuditable` interface for entities that need audit fields
-   Use `ISoftDelete` interface for soft-delete support if needed

## Code Style

-   Use **C# 12** features where appropriate
-   Follow C# naming conventions:
    -   Classes: PascalCase
    -   Methods: PascalCase
    -   Properties: PascalCase
    -   Private fields: `_camelCase`
    -   Parameters: camelCase
-   Use file-scoped namespaces: `namespace YGZ.Basket.{Layer}.{Feature};`
-   Use primary constructors where appropriate (C# 12)
-   Use `var` for local variables when type is obvious
-   Use expression-bodied members when appropriate
-   Use `sealed record` for commands and queries
-   Use `required` keyword for required properties in DTOs

## Controllers

-   All controllers inherit from `ApiController` base class
-   Use MediatR `ISender` to send commands/queries:
    ```csharp
    var result = await _sender.Send(command, cancellationToken);
    return result.Match(onSuccess: Ok, onFailure: HandleFailure);
    ```
-   Use Mapster `IMapper` for request-to-command/query mapping
-   Route pattern: `[Route("api/v{version:apiVersion}/baskets")]`
-   Use API versioning attributes: `[ApiVersion(1)]`
-   Use `[OpenApiTag]` for Swagger documentation
-   Use `CancellationToken` in all async controller methods
-   Use `[ProtectedResource]` for resource-based authorization

## Dependency Injection

-   Use extension methods for layer registration:
    -   `AddPresentationLayer()` in API layer (`DependencyInjection.cs`)
    -   `AddApplicationLayer(configuration)` in Application layer (`DependencyInjection.cs`)
    -   `AddInfrastructureLayer(configuration)` in Infrastructure layer (`DependencyInjection.cs`)
-   Register MediatR handlers: `services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(ApplicationAssembly).Assembly))`
-   Register FluentValidation validators: `services.AddFluentValidation(cfg => cfg.RegisterValidatorsFromAssembly(...))`
-   Register Mapster mappings: `services.AddSingleton<IMapper>(new Mapper(...))`
-   Register payment providers and cache repositories in Infrastructure layer

## Error Handling

-   Use `GlobalExceptionHandler` from BuildingBlocks for unhandled exceptions
-   Use `ApplicationProblemDetailsFactory` for consistent error responses
-   Controllers use `HandleFailure` method from `ApiController` base class
-   Never expose internal exceptions to clients; map to user-friendly errors
-   Use domain errors from `Domain/Core/Errors/` for business logic failures

## Logging

-   Use **Serilog** for structured logging
-   Use `ILogger<T>` with dependency injection
-   Configure Serilog via `AddSerilogExtension` extension method
-   Use **OpenTelemetry** for distributed tracing

## Health Checks

-   Register health checks in `Program.cs`
-   Map health endpoint: `app.MapHealthChecks("/health", new HealthCheckOptions { ... })`
-   Include MongoDB and Redis health checks

## Security

-   Never commit secrets or connection strings
-   Use `IConfiguration` and `appsettings.json` for configuration
-   Use environment-specific `appsettings.{Environment}.json` files
-   Validate all inputs; never trust client data
-   Use HTTPS in production
-   Secure payment provider credentials and connection strings
-   Use authentication and authorization for all basket operations

## Performance

-   Use async/await for all I/O operations
-   Use `CancellationToken` throughout async chains
-   Implement caching for frequently accessed data (prices, models, colors)
-   Use cached repositories for basket operations
-   Use `ConfigureHttpClientDefaults` with resilience handlers for external HTTP calls (payment providers, catalog service)

## Code Organization

-   Group related files by feature, not by type
-   Keep controllers thin; business logic belongs in Application layer
-   Use extension methods for cross-cutting concerns
-   Keep domain entities pure; no infrastructure dependencies
-   Use value objects for domain concepts (e.g., `Model`, `Color`, `Storage`, `Promotion`)
-   Each command/query in its own folder with handler and optional validator
-   Use factory methods for entity creation

## Common Patterns

-   **Pipeline Behaviors**: Use `ValidationPipelineBehavior` and `RequestLoggingPipelineBehavior` from BuildingBlocks
-   **Mapping**: Use Mapster for DTO-to-command/query mapping (location: `Api/Mappings/`)
-   **Pagination**: Use `PaginationResponse<T>` and `PaginationLinks` from BuildingBlocks if needed
-   **Filtering/Sorting**: Use query builders and expression builders from BuildingBlocks utilities

## Basket-Specific Features

-   **Shopping Cart Management**: Store, sync, update, and delete shopping carts
-   **Cart Items**: Add, update, and remove items from cart
-   **Event Items**: Support promotional event items in cart
-   **Checkout**: Process checkout with payment providers (Vnpay, Momo, Blockchain)
-   **Promotions**: Apply promotion coupons and calculate discounts
-   **Price Caching**: Cache product prices, models, and color images for performance
-   **Cart Filtering**: Filter cart items by selection status and event items
-   **Discount Calculation**: Calculate discounts based on promotion type and discount rules

## Inter-Service Communication

-   Communicate with **Catalog Service** for product information (models, prices, SKUs)
-   Communicate with **Discount Service** for promotion and coupon validation
-   Communicate with **Ordering Service** for order creation after checkout
-   Use **gRPC** for synchronous inter-service calls
-   Use **Messaging** (via BuildingBlocks.Messaging) for asynchronous event-driven communication
-   Use shared contracts from `YGZ.BuildingBlocks.Shared.Contracts` for consistency

## Background Services

-   Background services location: `Infrastructure/BackgroundServices/`
-   Use for periodic tasks (cache warming, cleanup, etc.)

## Settings

-   Settings classes location: `Infrastructure/Settings/`
-   Examples: `VnpaySettings.cs`, `MomoSettings.cs`, `WebClientSettings.cs`
-   Bind from `IConfiguration` in `Program.cs` or `DependencyInjection.cs`
